<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calculadora de InterseÃ§Ã£o Ã  Vante - Topografia</title>
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Leaflet CSS & JS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <!-- Proj4js para conversÃ£o de coordenadas -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
        }

        #map {
            height: 500px;
            width: 100%;
            z-index: 10;
            border-radius: 0.5rem;
        }

        /* AnimaÃ§Ãµes */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .animate-fadeIn {
            animation: fadeIn 0.5s ease-out forwards;
        }
    </style>
</head>

<body class="bg-gray-50">
    <div id="root"></div>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Componente do Mapa
        const MapViewer = ({ pontos, resultado, zonaUTM, hemisferio }) => {
            const mapRef = useRef(null);
            const mapInstanceRef = useRef(null);
            const layerGroupRef = useRef(null);

            useEffect(() => {
                if (!mapInstanceRef.current) {
                    // Inicializa o mapa
                    mapInstanceRef.current = L.map('map').setView([-15.7801, -47.9292], 4);

                    // Camadas de base
                    const googleSat = L.tileLayer('http://{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
                        maxZoom: 20,
                        subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
                        attribution: 'Google Satellite'
                    });

                    const googleHybrid = L.tileLayer('http://{s}.google.com/vt/lyrs=s,h&x={x}&y={y}&z={z}', {
                        maxZoom: 20,
                        subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
                        attribution: 'Google Hybrid'
                    });

                    const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        maxZoom: 19,
                        attribution: 'Â© OpenStreetMap'
                    }).addTo(mapInstanceRef.current);

                    const baseMaps = {
                        "OpenStreetMap": osm,
                        "Google SatÃ©lite": googleSat,
                        "Google HÃ­brido": googleHybrid
                    };

                    L.control.layers(baseMaps).addTo(mapInstanceRef.current);
                    layerGroupRef.current = L.layerGroup().addTo(mapInstanceRef.current);
                }
            }, []);

            useEffect(() => {
                if (resultado && mapInstanceRef.current && layerGroupRef.current) {
                    const layerGroup = layerGroupRef.current;
                    layerGroup.clearLayers();

                    try {
                        // DefiniÃ§Ã£o da projeÃ§Ã£o UTM
                        // WGS84 Ã© o padrÃ£o para GPS/Google Maps
                        const utmCode = `+proj=utm +zone=${zonaUTM} +${hemisferio === 'S' ? 'south' : 'north'} +datum=WGS84 +units=m +no_defs`;

                        // Converter coordenadas e centralizar
                        const utmToLatLng = (x, y) => {
                            // proj4.defs('UTM', utmCode); // NÃ£o precisa registrar globalmente se usar string direta
                            const result = proj4(utmCode, 'EPSG:4326', [parseFloat(x), parseFloat(y)]);
                            return [result[1], result[0]]; // [lat, lon]
                        };

                        const latLngA = utmToLatLng(resultado.xA_orig, resultado.yA_orig);
                        const latLngB = utmToLatLng(resultado.xB_orig, resultado.yB_orig);
                        const latLngP = utmToLatLng(resultado.xP_A, resultado.yP_A);

                        const bounds = L.latLngBounds([latLngA, latLngB, latLngP]);
                        mapInstanceRef.current.fitBounds(bounds, { padding: [50, 50] });

                        // Marcadores Customizados
                        const createMarker = (latLng, label, color, description) => {
                            const icon = L.divIcon({
                                className: 'custom-div-icon',
                                html: `<div style="background-color: ${color}; width: 14px; height: 14px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.4);"></div>`,
                                iconSize: [14, 14],
                                iconAnchor: [7, 7]
                            });

                            return L.marker(latLng, { icon })
                                .bindPopup(`<b>${label}</b><br>${description}`)
                                .bindTooltip(label, { permanent: true, direction: "top", offset: [0, -10], className: 'bg-white px-2 py-1 rounded shadow text-xs font-bold border border-gray-200' })
                                .addTo(layerGroup);
                        };

                        createMarker(latLngA, pontos.nomeA, '#2563eb', `EstaÃ§Ã£o A<br>E: ${resultado.xA_orig}<br>N: ${resultado.yA_orig}`);
                        createMarker(latLngB, pontos.nomeB, '#16a34a', `EstaÃ§Ã£o B<br>E: ${resultado.xB_orig}<br>N: ${resultado.yB_orig}`);

                        // Marcador do Ponto Calculado
                        const pMarker = L.marker(latLngP, {
                            icon: L.divIcon({
                                className: 'custom-div-icon',
                                html: `<div style="background-color: #dc2626; width: 16px; height: 16px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.4);"></div>`,
                                iconSize: [16, 16],
                                iconAnchor: [8, 8]
                            })
                        }).bindPopup(`<b>${pontos.nome} (Calculado)</b><br>E: ${resultado.xP_A.toFixed(3)}<br>N: ${resultado.yP_A.toFixed(3)}`)
                            .bindTooltip(pontos.nome, { permanent: true, direction: "top", offset: [0, -12], className: 'bg-red-50 text-red-700 px-2 py-1 rounded shadow text-xs font-bold border border-red-200' })
                            .addTo(layerGroup);


                        // Desenhar triÃ¢ngulo
                        const triangle = L.polygon([latLngA, latLngB, latLngP], {
                            color: '#4f46e5',
                            fillColor: '#4f46e5',
                            fillOpacity: 0.15,
                            weight: 2,
                            dashArray: '5, 5'
                        }).addTo(layerGroup);

                        // Desenhar Azimutes (Linhas sÃ³lidas para as visadas)
                        // A -> P
                        L.polyline([latLngA, latLngP], { color: '#2563eb', weight: 2, opacity: 0.8 }).bindTooltip(`Az Aâ†’P: ${resultado.azAP.toFixed(4)}Â°`, { sticky: true, direction: 'center' }).addTo(layerGroup);
                        // B -> P
                        L.polyline([latLngB, latLngP], { color: '#16a34a', weight: 2, opacity: 0.8 }).bindTooltip(`Az Bâ†’P: ${resultado.azBP.toFixed(4)}Â°`, { sticky: true, direction: 'center' }).addTo(layerGroup);
                        // A -> B (Base)
                        L.polyline([latLngA, latLngB], { color: '#4b5563', weight: 2, dashArray: '5, 5', opacity: 0.6 }).bindTooltip(`Base AB: ${resultado.dAB.toFixed(3)}m`, { sticky: true, direction: 'center' }).addTo(layerGroup);


                        // Popup com detalhes geomÃ©tricos
                        triangle.bindPopup(`
                            <div class="text-sm">
                                <b class="text-indigo-700">TriÃ¢ngulo TopogrÃ¡fico</b><hr class="my-1"/>
                                <b>Ã‚ngulos Internos:</b><br>
                                Ã‚ng. A: ${resultado.angA.toFixed(4)}Â°<br>
                                Ã‚ng. B: ${resultado.angB.toFixed(4)}Â°<br>
                                Ã‚ng. P: ${resultado.angP.toFixed(4)}Â°<br>
                                <hr class="my-1"/>
                                <b>Azimutes:</b><br>
                                Az AB: ${resultado.azAB.toFixed(4)}Â°<br>
                                Az AP: ${resultado.azAP.toFixed(4)}Â°<br>
                                Az BP: ${resultado.azBP.toFixed(4)}Â°
                            </div>
                        `);

                    } catch (error) {
                        console.error("Erro ao plotar no mapa:", error);
                        // Fallback user alert (in a real app, use a toast)
                        // alert("Erro ao projetar coordenadas. Verifique se o Fuso UTM estÃ¡ correto.");
                    }
                }
            }, [resultado, pontos, zonaUTM, hemisferio]);

            return <div id="map" className="shadow-lg border border-gray-200 bg-gray-100"></div>;
        };

        const IntersecaoVanteRelatorio = () => {
            const [pontos, setPontos] = useState([
                {
                    id: 1,
                    nome: 'L2',
                    xA: '293109.076474',
                    yA: '9210945.891067',
                    nomeA: 'M0',
                    xB: '293189.109326',
                    yB: '9210923.173231',
                    nomeB: 'M1',
                    dhAP: '324.475278',
                    dhBP: '13.485000',
                    resultado: null
                }
            ]);

            const [pontoAtivo, setPontoAtivo] = useState(0);

            // Novos estados para configuraÃ§Ã£o do mapa
            const [zonaUTM, setZonaUTM] = useState('24'); // PadrÃ£o comum BR
            const [hemisferio, setHemisferio] = useState('S');

            const adicionarPonto = () => {
                const novoPonto = {
                    id: pontos.length + 1,
                    nome: `Ponto ${pontos.length + 1}`,
                    xA: pontos[pontoAtivo].xA,
                    yA: pontos[pontoAtivo].yA,
                    nomeA: pontos[pontoAtivo].nomeA,
                    xB: pontos[pontoAtivo].xB,
                    yB: pontos[pontoAtivo].yB,
                    nomeB: pontos[pontoAtivo].nomeB,
                    dhAP: '',
                    dhBP: '',
                    resultado: null
                };
                setPontos([...pontos, novoPonto]);
                setPontoAtivo(pontos.length);
            };

            const removerPonto = (index) => {
                if (pontos.length > 1) {
                    const novosPontos = pontos.filter((_, i) => i !== index);
                    setPontos(novosPontos);
                    setPontoAtivo(Math.max(0, index - 1));
                }
            };

            const atualizarPonto = (campo, valor) => {
                const novosPontos = [...pontos];
                novosPontos[pontoAtivo][campo] = valor;
                setPontos(novosPontos);
            };

            // Normaliza qualquer Ã¢ngulo para o intervalo 0â€“360Â°
            const normalizarAngulo = (angulo) => {
                return ((angulo % 360) + 360) % 360;
            };

            const calcular = () => {
                const p = pontos[pontoAtivo];

                const xA = parseFloat(p.xA);
                const yA = parseFloat(p.yA);
                const xB = parseFloat(p.xB);
                const yB = parseFloat(p.yB);
                const dhAP = parseFloat(p.dhAP);
                const dhBP = parseFloat(p.dhBP);

                const deltaX_AB = xB - xA;
                const deltaY_AB = yB - yA;

                let azAB_rad = Math.atan2(deltaX_AB, deltaY_AB);
                let azAB = azAB_rad * (180 / Math.PI);
                if (azAB < 0) azAB += 360;

                const dAB = Math.sqrt(deltaX_AB ** 2 + deltaY_AB ** 2);

                let azAP = azAB + dhAP;
                if (azAP >= 360) azAP -= 360;

                let azBA = azAB + 180;
                if (azBA >= 360) azBA -= 360;

                let azBP = azBA + dhBP;
                if (azBP >= 360) azBP -= 360;

                // Ã‚ngulos internos do triÃ¢ngulo ABP (NORMALIZADOS)
                let angA = normalizarAngulo(360 - (azAP - azAB));
                let angB = normalizarAngulo(azBP - azBA);

                // Ã‚ngulo em P fecha o triÃ¢ngulo
                let angP = 180 - angA - angB;

                const somaAngulos = angA + angB + angP;

                const angA_rad = angA * Math.PI / 180;
                const angB_rad = angB * Math.PI / 180;
                const angP_rad = angP * Math.PI / 180;

                const dAP = dAB * Math.sin(angB_rad) / Math.sin(angP_rad);
                const dBP = dAB * Math.sin(angA_rad) / Math.sin(angP_rad);

                const azAP_rad = azAP * Math.PI / 180;
                const xP_A = xA + dAP * Math.sin(azAP_rad);
                const yP_A = yA + dAP * Math.cos(azAP_rad);

                const azBP_rad = azBP * Math.PI / 180;
                const xP_B = xB + dBP * Math.sin(azBP_rad);
                const yP_B = yB + dBP * Math.cos(azBP_rad);

                const erro_x = xP_A - xP_B;
                const erro_y = yP_A - yP_B;
                // Erro linear independente (RMS)
                const erro_linear = Math.sqrt((erro_x ** 2 + erro_y ** 2) / 2);

                const resultado = {
                    deltaX_AB, deltaY_AB,
                    azAB, dAB,
                    azAP, azBA, azBP,
                    angA, angB, angP, somaAngulos,
                    dAP, dBP,
                    xP_A, yP_A, xP_B, yP_B,
                    erro_x, erro_y, erro_linear,
                    // Preservar valores originais para plotagem
                    xA_orig: xA, yA_orig: yA,
                    xB_orig: xB, yB_orig: yB
                };

                const novosPontos = [...pontos];
                novosPontos[pontoAtivo].resultado = resultado;
                setPontos(novosPontos);
            };

            const copiarRelatorio = () => {
                const p = pontos[pontoAtivo];
                const r = p.resultado;

                const texto = `RELATÃ“RIO TÃ‰CNICO - INTERSEÃ‡ÃƒO Ã€ VANTE
Ponto: ${p.nome}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. DADOS DE ENTRADA
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
EstaÃ§Ã£o A (${p.nomeA}):  X = ${p.xA} m,  Y = ${p.yA} m
EstaÃ§Ã£o B (${p.nomeB}):  X = ${p.xB} m,  Y = ${p.yB} m
DireÃ§Ã£o Horizontal Aâ†’P: ${p.dhAP}Â°
DireÃ§Ã£o Horizontal Bâ†’P: ${p.dhBP}Â°

2. CÃLCULO DE AZIMUTE E DISTÃ‚NCIA AB
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î”X_AB = ${r.deltaX_AB.toFixed(6)} m
Î”Y_AB = ${r.deltaY_AB.toFixed(6)} m
Az_AB = ${r.azAB.toFixed(6)}Â°
DistÃ¢ncia AB = ${r.dAB.toFixed(6)} m

3. AZIMUTES PARA O PONTO P
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Az_AP = Az_AB + DH_A = ${r.azAP.toFixed(6)}Â°
Az_BA = Az_AB + 180Â° = ${r.azBA.toFixed(6)}Â°
Az_BP = Az_BA + DH_B = ${r.azBP.toFixed(6)}Â°

4. Ã‚NGULOS INTERNOS DO TRIÃ‚NGULO
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Ã‚ngulo em A = ${r.angA.toFixed(6)}Â°
Ã‚ngulo em B = ${r.angB.toFixed(6)}Â°
Ã‚ngulo em P = ${r.angP.toFixed(6)}Â°
Soma = ${r.somaAngulos.toFixed(6)}Â° (deve ser 180Â°)

5. DISTÃ‚NCIAS (LEI DOS SENOS)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
DistÃ¢ncia AP = ${r.dAP.toFixed(6)} m
DistÃ¢ncia BP = ${r.dBP.toFixed(6)} m

6. COORDENADAS DO PONTO P
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Calculado de A:  X = ${r.xP_A.toFixed(6)} m,  Y = ${r.yP_A.toFixed(6)} m
Calculado de B:  X = ${r.xP_B.toFixed(6)} m,  Y = ${r.yP_B.toFixed(6)} m

7. ERRO DE FECHAMENTO
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î”X = ${r.erro_x.toFixed(6)} m
Î”Y = ${r.erro_y.toFixed(6)} m
Erro Linear = ${r.erro_linear.toFixed(6)} m = ${(r.erro_linear * 1000).toFixed(3)} mm

8. RESULTADO FINAL
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Ponto ${p.nome}:  X = ${r.xP_A.toFixed(6)} m,  Y = ${r.yP_A.toFixed(6)} m
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`;

                navigator.clipboard.writeText(texto);
                alert('RelatÃ³rio copiado para a Ã¡rea de transferÃªncia!');
            };

            const pontoAtual = pontos[pontoAtivo];
            const r = pontoAtual?.resultado;

            return (
                <div className="max-w-7xl mx-auto p-4 md:p-6 bg-gray-50 min-h-screen">
                    <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                        <div className="flex items-center justify-between mb-6 flex-wrap gap-4">
                            <div className="flex items-center gap-3">
                                <span className="text-4xl">ğŸ“</span>
                                <div>
                                    <h1 className="text-2xl font-bold text-gray-800">
                                        Calculadora TopogrÃ¡fica
                                    </h1>
                                    <p className="text-sm text-gray-500">InterseÃ§Ã£o Ã  Vante & VisualizaÃ§Ã£o Satelital</p>
                                </div>
                            </div>
                            <button
                                onClick={adicionarPonto}
                                className="flex items-center gap-2 bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700 shadow transition"
                            >
                                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                                </svg>
                                Novo Ponto
                            </button>
                        </div>
                        {/* ConfiguraÃ§Ã£o de GPS */}
                        <div className="mb-6 p-4 bg-gray-100 rounded-lg flex flex-wrap gap-4 items-center border border-gray-200">
                            <div className="flex items-center gap-2">
                                <span className="font-bold text-gray-700">ğŸŒ ConfiguraÃ§Ã£o UTM:</span>
                            </div>
                            <div className="flex items-center gap-2">
                                <label className="text-sm">Zona:</label>
                                <input
                                    type="number"
                                    value={zonaUTM}
                                    onChange={(e) => setZonaUTM(e.target.value)}
                                    className="w-16 p-1 border rounded text-center"
                                />
                            </div>
                            <div className="flex items-center gap-2">
                                <label className="text-sm">HemisfÃ©rio:</label>
                                <select
                                    value={hemisferio}
                                    onChange={(e) => setHemisferio(e.target.value)}
                                    className="p-1 border rounded"
                                >
                                    <option value="S">Sul</option>
                                    <option value="N">Norte</option>
                                </select>
                            </div>
                            <span className="text-xs text-gray-500 ml-auto hidden md:inline bg-white px-2 py-1 rounded border">NecessÃ¡rio para plotagem no mapa global</span>
                        </div>


                        {/* Abas de pontos */}
                        <div className="flex gap-2 mb-6 overflow-x-auto pb-2 scrollbar-thin">
                            {pontos.map((ponto, index) => (
                                <div key={ponto.id} className="flex items-center gap-1 shrink-0">
                                    <button
                                        onClick={() => setPontoAtivo(index)}
                                        className={`px-4 py-2 rounded-t-lg font-medium transition whitespace-nowrap border-b-2 ${pontoAtivo === index
                                                ? 'bg-blue-50 text-blue-700 border-blue-600'
                                                : 'bg-white text-gray-700 border-transparent hover:bg-gray-50'
                                            }`}
                                    >
                                        {ponto.nome}
                                    </button>
                                    {pontos.length > 1 && (
                                        <button
                                            onClick={() => removerPonto(index)}
                                            className="p-1 text-red-600 hover:bg-red-100 rounded"
                                        >
                                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                                            </svg>
                                        </button>
                                    )}
                                </div>
                            ))}
                        </div>

                        {/* FormulÃ¡rio de entrada */}
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                            {/* IdentificaÃ§Ã£o */}
                            <div className="md:col-span-2 p-4 border border-purple-200 bg-purple-50 rounded-lg">
                                <h3 className="font-bold text-purple-900 mb-3 flex items-center gap-2">
                                    <span>ğŸ“</span> IdentificaÃ§Ã£o
                                </h3>
                                <input
                                    type="text"
                                    value={pontoAtual.nome}
                                    onChange={(e) => atualizarPonto('nome', e.target.value)}
                                    className="w-full p-2 border rounded focus:ring-2 focus:ring-purple-300 outline-none transition"
                                    placeholder="Nome do ponto (ex: L2, P1, etc.)"
                                />
                            </div>

                            {/* EstaÃ§Ã£o A */}
                            <div className="bg-blue-50 p-4 border border-blue-200 rounded-lg">
                                <h3 className="font-bold text-blue-900 mb-3">EstaÃ§Ã£o A (Origem)</h3>
                                <div className="space-y-2">
                                    <div>
                                        <label className="block text-sm font-medium mb-1">Nome</label>
                                        <input
                                            type="text"
                                            value={pontoAtual.nomeA}
                                            onChange={(e) => atualizarPonto('nomeA', e.target.value)}
                                            className="w-full p-2 border rounded focus:ring-2 focus:ring-blue-300"
                                        />
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium mb-1">Coordenada X (E)</label>
                                        <input
                                            type="text"
                                            value={pontoAtual.xA}
                                            onChange={(e) => atualizarPonto('xA', e.target.value)}
                                            className="w-full p-2 border rounded focus:ring-2 focus:ring-blue-300"
                                        />
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium mb-1">Coordenada Y (N)</label>
                                        <input
                                            type="text"
                                            value={pontoAtual.yA}
                                            onChange={(e) => atualizarPonto('yA', e.target.value)}
                                            className="w-full p-2 border rounded focus:ring-2 focus:ring-blue-300"
                                        />
                                    </div>
                                </div>
                            </div>

                            {/* EstaÃ§Ã£o B */}
                            <div className="bg-green-50 p-4 border border-green-200 rounded-lg">
                                <h3 className="font-bold text-green-900 mb-3">EstaÃ§Ã£o B (ReferÃªncia)</h3>
                                <div className="space-y-2">
                                    <div>
                                        <label className="block text-sm font-medium mb-1">Nome</label>
                                        <input
                                            type="text"
                                            value={pontoAtual.nomeB}
                                            onChange={(e) => atualizarPonto('nomeB', e.target.value)}
                                            className="w-full p-2 border rounded focus:ring-2 focus:ring-green-300"
                                        />
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium mb-1">Coordenada X (E)</label>
                                        <input
                                            type="text"
                                            value={pontoAtual.xB}
                                            onChange={(e) => atualizarPonto('xB', e.target.value)}
                                            className="w-full p-2 border rounded focus:ring-2 focus:ring-green-300"
                                        />
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium mb-1">Coordenada Y (N)</label>
                                        <input
                                            type="text"
                                            value={pontoAtual.yB}
                                            onChange={(e) => atualizarPonto('yB', e.target.value)}
                                            className="w-full p-2 border rounded focus:ring-2 focus:ring-green-300"
                                        />
                                    </div>
                                </div>
                            </div>

                            {/* DireÃ§Ãµes Horizontais */}
                            <div className="md:col-span-2 bg-yellow-50 border border-yellow-200 p-4 rounded-lg">
                                <h3 className="font-bold text-yellow-900 mb-3">DireÃ§Ãµes Horizontais Observadas (graus decimais)</h3>
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    <div>
                                        <label className="block text-sm font-medium mb-1">DH de A para P (Â°)</label>
                                        <input
                                            type="text"
                                            value={pontoAtual.dhAP}
                                            onChange={(e) => atualizarPonto('dhAP', e.target.value)}
                                            className="w-full p-2 border rounded focus:ring-2 focus:ring-yellow-300"
                                            placeholder="324.475278"
                                        />
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium mb-1">DH de B para P (Â°)</label>
                                        <input
                                            type="text"
                                            value={pontoAtual.dhBP}
                                            onChange={(e) => atualizarPonto('dhBP', e.target.value)}
                                            className="w-full p-2 border rounded focus:ring-2 focus:ring-yellow-300"
                                            placeholder="13.485000"
                                        />
                                    </div>
                                </div>
                            </div>
                        </div>

                        <button
                            onClick={calcular}
                            className="w-full bg-gradient-to-r from-blue-600 to-indigo-600 text-white py-4 rounded-lg font-bold hover:from-blue-700 hover:to-indigo-700 transition mb-6 shadow-md text-lg flex items-center justify-center gap-2 transform active:scale-[0.99]"
                        >
                            <span>ğŸš€</span> CALCULAR E PLOTAR NO MAPA
                        </button>

                        {/* MAPA */}
                        {r && (
                            <div className="mb-8">
                                <h3 className="text-xl font-bold text-gray-800 mb-4 flex items-center gap-2">
                                    <span>ğŸ›°ï¸</span> VisualizaÃ§Ã£o Espacial
                                </h3>
                                <div className="rounded-lg overflow-hidden ring-4 ring-gray-200">
                                    <MapViewer
                                        pontos={pontoAtual}
                                        resultado={r}
                                        zonaUTM={zonaUTM}
                                        hemisferio={hemisferio}
                                    />
                                </div>
                                <p className="text-xs text-center mt-2 text-gray-500">
                                    Certifique-se que o fuso UTM ({zonaUTM}{hemisferio}) corresponde Ã s coordenadas inseridas.
                                </p>
                            </div>
                        )}


                        {/* Resultados em Texto */}
                        {r && (
                            <div className="space-y-4 animate-fadeIn">
                                <div className="flex items-center justify-between mb-4 flex-wrap gap-4 border-b pb-2">
                                    <h2 className="text-xl font-bold text-gray-800">RelatÃ³rio de CÃ¡lculo</h2>
                                    <button
                                        onClick={copiarRelatorio}
                                        className="flex items-center gap-2 bg-gray-600 text-white px-4 py-2 rounded-lg hover:bg-gray-700 text-sm"
                                    >
                                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                                        </svg>
                                        Copiar Texto
                                    </button>
                                </div>

                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    {/* Passo 3 e 4 agrupados */}
                                    <div className="p-4 bg-gray-50 rounded-lg border">
                                        <h3 className="font-bold text-gray-900 mb-2 text-sm uppercase">Geometria Base (A-B)</h3>
                                        <div className="text-sm space-y-1">
                                            <div className="flex justify-between"><span>Azimute AB:</span> <span className="font-mono">{r.azAB.toFixed(4)}Â°</span></div>
                                            <div className="flex justify-between"><span>DistÃ¢ncia AB:</span> <span className="font-mono">{r.dAB.toFixed(3)} m</span></div>
                                        </div>
                                    </div>

                                    <div className="p-4 bg-gray-50 rounded-lg border">
                                        <h3 className="font-bold text-gray-900 mb-2 text-sm uppercase">Ã‚ngulos Internos</h3>
                                        <div className="text-sm space-y-1">
                                            <div className="flex justify-between"><span>Ã‚ngulo A:</span> <span className="font-mono">{r.angA.toFixed(4)}Â°</span></div>
                                            <div className="flex justify-between"><span>Ã‚ngulo B:</span> <span className="font-mono">{r.angB.toFixed(4)}Â°</span></div>
                                            <div className="flex justify-between border-t pt-1 font-semibold"><span>Ã‚ngulo P:</span> <span className="font-mono">{r.angP.toFixed(4)}Â°</span></div>
                                        </div>
                                    </div>
                                </div>

                                {/* Resultado Final */}
                                <div className="p-6 bg-gradient-to-r from-blue-600 to-blue-800 text-white rounded-lg shadow-lg transform transition hover:scale-[1.01]">
                                    <div className="flex items-start justify-between">
                                        <div>
                                            <h3 className="font-bold text-lg mb-1 opacity-90">COORDENADAS DO PONTO {pontoAtual.nome}</h3>
                                            <div className="text-3xl font-bold tracking-tight mb-2">
                                                <div className="flex items-center gap-4 flex-wrap">
                                                    <span>E: {r.xP_A.toFixed(3)}</span>
                                                    <span>N: {r.yP_A.toFixed(3)}</span>
                                                </div>
                                            </div>
                                            <div className="text-sm opacity-75">
                                                Erro Linear Estimado: {(r.erro_linear * 1000).toFixed(1)} mm
                                            </div>
                                        </div>
                                        <div className="hidden md:block text-5xl opacity-20">ğŸ¯</div>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Metodologia Footer */}
                        <div className="mt-8 p-4 bg-white border border-gray-100 rounded-lg text-xs text-gray-400 text-center">
                            Calculadora TopogrÃ¡fica Profissional â€¢ v2.0 â€¢ Sistema de ProjeÃ§Ã£o UTM
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<IntersecaoVanteRelatorio />);
    </script>
</body>

</html>
